#ifndef App_hpp
#define App_hpp
#include <deque>
#include "GlutApp.h"
#include <cmath>
class App : public GlutApp {
	// Maintain app state here
	float mx;
	float my;
public:
	// Constructor, to initialize state
	App(const char* label, int x, int y, int w, int h);

	// These are the events we want to handle
	void draw();
	void keyPress(unsigned char key);
	void mouseDown(float x, float y);
	void mouseDrag(float x, float y);
};

class Rect
{
public:
	float x, y, width, height;
	bool containsC;
	bool taken; 
	int whatShape; //checks the value of the shape
public:

	Rect()
	{
		x = 0.0f;
		y = 0.0f;
		width = 0.0f;
		height = 0.0f;
		containsC = false;
		taken = false;
		whatShape = 0;
	}


	Rect(float xx, float yy, float w, float h) {
		x = xx;
		y = yy;
		width = w;
		height = h;
	}

	float getY() const
	{
		return y;
	}
	float getX() const
	{
		return x;
	}
	float getW() const
	{
		return width;
	}
	float getH() const
	{
		return height;
	}
	void setwhatShape(int shape)
	{
		whatShape = shape;
	}
	int getShape() const
	{
		return whatShape;
	}
	bool getContainsC() const
	{
		return containsC;
	}
	void setContainsC(bool cont)
	{
		containsC = cont;
	}
	void setTaken(bool take)
	{
		taken = take;
	}
	bool getTaken()
	{
		return taken;
	}
	void setX(float xx)
	{
		x = xx;
	}
	void setY(float yy)
	{
		y = yy;
	}

	bool contains(float x, float y) //contains function to see if a cell is clicked
	{
		if (x >= this->x && this->x + this->width >= x) {
			if (y <= this->y && y >= this->y - this->height) {
				containsC = true;
			}
		}
		else
			containsC = false;
	}
	void draw() { //draw the cell squares if you want in this case i did white squares
		glColor3d(0.0, 0.0, 0.0);
		glBegin(GL_POLYGON);

		glVertex2f(getX(), getY());
		glVertex2f(getX() + getW(), getY());
		glVertex2f(getX() + getW(), getY() - getH());
		glVertex2f(getX(), getY() - getH());

		glEnd();
	}

};

class Grid
{
public:
	float x, y, width, height;
public:

	Grid()
	{
		x = 0.0f;
		y = 0.0f;
		width = 0.0f;
		height = 0.0f;
	}


	Grid(float xx, float yy, float w, float h) {
		x = xx;
		y = yy;
		width = w;
		height = h;
	}

	float getY() const
	{
		return y;
	}
	float getX() const
	{
		return x;
	}
	float getW() const
	{
		return width;
	}
	float getH() const
	{
		return height;
	}

	void draw() { //draws grid outline

		glColor3d(1.0, 1.0, 1.0);
		glBegin(GL_POLYGON);

		glVertex2f(getX(), getY());
		glVertex2f(getX() + getW(), getY());
		glVertex2f(getX() + getW(), getY() - getH());
		glVertex2f(getX(), getY() - getH());
		glEnd();
	}
};

class Shape
{
public:
	float x, y, radius;
	int resolution;
	bool filled;//stops this object from getting overwritten
	int whatShape; //0 = no shape, 1 = circle, 2 = an x
public:

	Shape()
	{
		x = 0.0f;
		y = 0.0f;
		filled = false;
	}


	Shape(float xx, float yy) {
		x = xx;
		y = yy;
	}
	void setXY(float xx, float yy)
	{
		x = xx;
		y = yy;
		resolution = 150; 
		radius = 0.20;
		whatShape = 0;
		if (xx != 0 && yy != 0)
			filled = true; //mark filled as true
	}
	float getY() const
	{
		return y;
	}
	float getX() const
	{
		return x;
	}
	float getRadius() const
	{
		return radius;
	}
	float getCenterX() const //centers the drawing for x value
	{
		if (x < -0.310)
			return (-0.66);
		else if (x > 0.310)
			return (0.66);
		else
			return 0;
	}
	float getCenterY() const //centers the drawing for y value
	{
		if (y < -0.310)
			return (-0.66);
		else if (y > 0.310)
			return (0.66);
		else
			return 0;
	}
	void setwhatShape(int shape) // sets the shape if 1 circle if 2 x
	{
		whatShape = shape;
	}
	int getShape() const
	{
		return whatShape;
	}
	bool isFilled()
	{
		return filled;
	}
	void setFilled(bool fill)
	{
		filled = fill;
	}
	void draw()
	{//draws a circle if 1 and draws an x if 2
		if (whatShape == 1) {//creates a circle
			glColor3d(1.0, 0.0, 0.0);
			glPointSize(15);
			glBegin(GL_POINTS);
			for (int i = -resolution; i < resolution; i++) {
				float angle = (i) * (360 / resolution);
				float degree = (angle * 3.1415 / 180);
				float circleX = getCenterX() + getRadius() * cos(degree);
				float circleY = getCenterY() + getRadius() * sin(degree);
				glVertex2f(circleX, circleY);
			}
			filled = true;
			glEnd();
		}
		else if (whatShape == 2) {//creates an x
			float tempy = y - 0.066;
			float tempx = x + 0.066;
			glBegin(GL_POLYGON);  //top line
			glVertex2f(tempx + 0.10, tempy);
			glVertex2f(tempx, tempy);
			glVertex2f(tempx + 0.40, tempy - 0.50);
			glVertex2f(tempx + 0.50, tempy - 0.50);
			glEnd();

			glBegin(GL_POLYGON); //bottom line
			glVertex2f(tempx + 0.10, tempy - 0.50);
			glVertex2f(tempx, tempy - 0.50);
			glVertex2f(tempx + 0.40, tempy);
			glVertex2f(tempx + 0.50, tempy);
			glEnd();
		}
	}


};

#endif
